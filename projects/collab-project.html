<!DOCTYPE HTML>
<!--
	Photon by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html lang="en_GB">
<head>
    <title>Cross-platform Engine Development - Portfolio</title>
    <link href="../images/favicon.png" rel="icon" type="image/x-icon">
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport"/>
    <link href="../assets/css/main.css" rel="stylesheet"/>
    <noscript>
        <link href="../assets/css/main.css" rel="stylesheet"/>
    </noscript>
</head>
<body class="is-preload">

<!-- Header -->
<section id="header" style="background-image: url(../images/cped_header.avif);
    background-size: cover; background-position: center; background-attachment: local">
    <h1 class="pageTitle">Collaborative Project: Cross-platform Engine Development</h1>
    <p class="pageTagline">Building a cross-platform game engine in a team of nine in eight weeks.</p>
</section>

<a class="button backButton" href="../index.html">
    <p class="backButton">BACK</p>
</a>

<!-- One -->
<section class="main style1" id="one" style="padding: 2em 1em 2em 1em">
    <div class="container" style="text-align: left">
        <h2 class="major centerTitle">Background</h2>
        <p>
            <!--<h3 class="major centerTitle">Demonstration Video</h3>-->
            <!--<div style="position: relative; width: 100%; height: 0; padding-bottom: 41.8604651163%">-->
            <!--    <iframe allow="autoplay" allowfullscreen-->
            <!--          src="https://www.youtube.com/embed/" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">-->
            <!--    </iframe>-->
            <!--</div>-->

            WRITE HERE ABOUT THE MAJOR FEATURES OF THE PROJECT I WORKED ON AND HOW THEY WORK!!
        </p>

        <h2 class="major centerTitle">Specifics of Features Implemented</h2>
        <h3 class="major centerTitle">Maths Library</h3>
        <p>
            A Maths Library is a critical feature of a cross-platform engine as many core features will rely on the functions and structs that are present within.
            I designed how the Maths Library works as well as added some of the functionality.
            <br/><br/>
            The functionality I added was Vector2, Vector3 and Vector4 classes. These each overloaded the +, -, *, /, +=, -=, *=, /=, == and != operators.
            As well as this, each class also contained functions, as well as static functions, to calculate dot, angle, magnitude, magnitude squared and vector normalized.
            <br/>
            Each one also contained static initializers for One and Zero, returning vectors that are prefilled with values. Vector2 and Vector3 also contain Up, Down,
            Left and Right initializers with Vector3 also containing Forward and Back - contextually indicating that Vector2 and Vector3 are used for 2D and 3D coordinate spaces.
            <br/><br/>
            Functions to calculate orthogonal projection and look-to view matrices were also added, although, many of the values that would be used were not, as the engine is
            specifically targeting 2D rendering.
        </p>
        <h3 class="major centerTitle">Renderer - DirectX 11</h3>
        <p>
            The DirectX 11 Renderer is the primary renderer of the project, with a different renderer having to be used for the PlayStation 5 Port of the Project.
            <br/><br/>
            The Renderers were implemented are in a way that means a specifical renderer could be conditionally compiled for the platform. The header file for the renderer
            acts as an interface for each renderer. Then, the implementation is linked at compile time - through selecting the implementation file.
            <br/><br/>
            As the project is 2D and sprite-based, the renderer interface was specialised to simply being able to call renderer::draw_sprite() which then
            is processed by the renderer itself, breaking down the tasks required to draw a sprite - such as binding data to shaders and dispatching draw calls.
            <br/>
            Around this, the renderer also has some extra functions that facilitate more of the renderer functionality. These are de/register_texture(),
            register_point/directional_light(), draw_sprite_late() and set_render_camera().
            <br/>
            Registering and deregistering a texture involves utilising the global unique identifier given to each texture fetched by the asset pipeline and
            passing this, along with a void* and texture resolution to the renderer to create a renderer specific resource. For example, in DirectX 11,
            textures need to be bound to a ID3D11ShaderResourceView, whereas this may not be the same in another renderer API. This is then, within the DirectX 11 renderer,
            inserted into a std::map of identifier and SRV.
            <br/>
            Registering point or directional lights passes the data required for each light to be rendered that frame.
            <br/>
            Drawing a sprite late draws a sprite after the rest of the rendering has taken place. This is used to render the cursor correctly, on top of all things on the screen.
            <br/>
            Finally, setting the render camera sets which camera should be used to render the scene. A quirk of this is that if there are multiple cameras, and more than one is
            active, the last camera called will be the one that is rendered with.
            <br/><br/>
            To facilitate much of the previously discussed engine features, wrappers around DirectX 11 datatypes were created.
            <br/>
            For example, SRVResource was created to wrap data management for a ID3D11ShaderResourceView. This provides a few helper functions to manage a ID3D11ShaderResourceView.
            Lighting can have many lights passed to the renderer, SRVResource can be used to resize the ID3D11ShaderResourceView at a rate of 2(n), as well as mapping to the GPU.
            <br/>
            Others include BufferResource for ID3D11Buffer and Texture2DResource for ID3D11Texture2D, ID3D11RenderTargetView and ID3D11ShaderResourceView.
        </p>

        <!--forum posts
        A majority of the initialisation for the DirectX 11 renderer was completed this week.
        The primary reason for using DirectX 11 for the Windows platform renderer was the speed at which DirectX 11 can be initialized and also,
        as the graphics programmer, my knowledge of DirectX 11.


        This is also the point in which the renderer was swapped back to 'normal' coordinate space, with X and Y, which was a fairly simple change within the matrix calculations.
        As well as this the renderer camera supports resizing. Due to how orthogonal projection works, the 'size' of a projection is 1:1 with world space coordinates,
        such that a size of 4x4 (assuming a square resolution) the corners will map to the world space coordinates of -4->4 in both X and Y, when the camera is at origin.
        With this being the case, I made the renderer camera not have any specific dominant axis - if the screen is wider than tall,
        the target zoom factor will be pinned to the height - the opposite when the height is bigger.
        This week a very simple and temporary sprite renderer was added to the renderer.
        The implementation was not concrete in any way and is meant to be temporary for the formative review -
        it breaks the logic of the program, with the renderer directly consuming the scene graph and knowing what a sprite renderer component is.
        When the component system is fully online then work can begin to move this into the component itself and have some way of having the sprite renderer component
        to register a draw call with the renderer.

        As previously mentioned, the renderer holds a lot of code that should be refactored when the time arrives -
        such as after last week when the Component system was solidified.
        To achieve renderer independence from other systems, the renderer is passed by reference through the on_draw() function so that the added functions can be used.
        Since this is a 2D engine and is designed to only render quads - there is a render_sprite() function on the renderer. Across this you pass the texture Id,
        the position, flipped state and colour. The Texture Id is set up by passing a void* to the texture data, the textures Id assigned by the image loader, width and height.
        This is enough data to create the resource on the renderer implementation - such as with DirectX - a ShaderResourceView.
        At this point too, the DirectX renderer was changed to only be able to render Quads through the shader, using the VertexID semantic to fetch the required data built
        into the shader - this reduces the need to bind to the DirectX 11 pipeline. Texture Flipping was also moved to the shader as previously it was built into the world matrix,
        which would require the SpriteRendererComponent to be able to decompose the world matrix and rebuild it - just to change the effective scale of the sprite.
        Instead, this is passed to the shader that instead flips the texture coordinates.

        During this week, whilst implementing lighting, I cleaned up many DirectX specific resources into containers that allow easy encapsulation of common behaviors -
        such as mapping buffers to the GPU. Or, functionality not intrinsic to the Resource - such as resizing them; DirectX requires that resources must be deleted
        and rebuilt to 'resize' them. This specific functionality is required to allow for an unlimited amount of lights - with a resize of 2(n).
        This keeps the buffer small to begin with whilst allowing it to grow if a large amount of lights is required.
        With more time this feature would have turned into a more robust system, as each implementation of 'wrapper' is independent and thrown together -
        such as the Texture2DResource which holds a Texture2D, RenderTargetView and ShaderResourceView, but also there is the SRVResource independent
        of the ShaderResourceView within the Texture2DResource.

        Also, this week, a small update to how Sprites are rendered - with layers.
        Whilst previously objects were rendered in whatever order they reached the renderer and there is no depth buffer bound in either renderer as
        there is no massively complicated geometry, or real need for the GPU to perform a depth test.
        Final task for the renderer is adding a 'late' render, which allows the cursor to render on top of all objects on screen and also not be affected by the lighting system.
        -->
    </div>
</section>

<!-- Footer -->
<section id="footer">
    <ul class="icons">
        <li class="icon"> <i class="fa-brands fa-linkedin"></i> - <a href="https://linkedin.com/in/ethirix" target="_blank">Jack
            Wright</a></li>
        <li class="icon"><i class="fa-brands fa-github"></i> - <a href="https://github.com/ethirix" target="_blank">Ethirix</a></li>
        <!--<li class="icon"><i class="fa-brands fa-twitter"></i> - <a href="https://twitter.com/ethirix" target="_blank">@Ethirix</a>-->
        <li class="icon"><i class="fa-brands fa-bluesky"></i> - <a href="https://bsky.app/profile/ethirix.dev" target="_blank">@ethirix.dev</a>
        </li>
    </ul>
    <ul class="copyright">
        <li>&copy; Jack Wright - All rights reserved.</li>
        <li>Design: <a href="https://html5up.net" target="_blank">HTML5 UP</a></li>
    </ul>
</section>

<!-- Scripts -->
<script src="../assets/js/jquery.min.js"></script>
<script src="../assets/js/jquery.scrolly.min.js"></script>
<script src="../assets/js/browser.min.js"></script>
<script src="../assets/js/breakpoints.min.js"></script>
<script src="../assets/js/util.js"></script>
<script src="../assets/js/main.js"></script>

</body>